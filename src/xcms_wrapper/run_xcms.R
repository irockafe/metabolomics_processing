# Script that accepts a user-generated parameters file,
# or a handful of preset LC-MS presets

# Input possibilities
# Rscript run_xcms.R --preset uplc_orbitrap
# Rscript run_xcms.R -sf summary_file.txt
library(optparse)
library(BiocParallel)
library(snowfall)
# library(CAMERA) TODO!

parser <- OptionParser()
parser <- add_option(parser, c('--summaryfile', '-s'), type='character',
    default=NULL, 
    help=paste('A file containing xcms parameters.',
   'If you run this script with no arguments,',
   'A mostly-blank summary file will be made',
   'You can then fill in parameters as you like.',
   'See the xcms documentation for defaults or if',
   'you are confused. Required.'))

parser <- add_option(parser, c('--data', '-d'), type='character',
		     default=NULL,
		     help=paste('Directory containing data for xcms
				to process. Required.'))

parser <- add_option(parser, c('--output', '-o'), type='character',
		     default=NULL,
		     help=paste('Path to output processed
				data to (single directory)'))

parser <- add_option(parser, c('--cores'), type='integer',
                     default = 4,
                     help=paste('Optional, number of cores to 
                        run things with'))

args = parse_args(parser)

# set number of cores to use
print(paste('Number of cores ', args$cores))
register(MulticoreParam(args$core))

### Parse a tab-delimited summary file
char_to_numeric <- function(char) {
   # Take in a space-delimited character that represents
   # a number or vector. Convert it to numeric.
   numeric <- as.numeric(strsplit(char, " ")[[1]])
    return(numeric)
}

get_params <- function(path, char_to_numeric) {
   # INPUT: tab-delim file of 
   # space-delimited values. Meaning that if you want c(20,60), 
   # You should input "20 60"	
   # OUTPUT: A labeled list with each label from the first column
   # of the file. Each value, character or numeric, from the second column
   # It will accept vectors as space-delimited entries in the second column 
   # of the text file
   df <- read.table(path, sep='\t', header=FALSE, row.names=1,
                    colClasses="character", blank.lines.skip=TRUE, 
                    fill=TRUE, strip.white=TRUE)
   print(df)
   print(dim(df))
   # There should only be one column of values
   if (dim(df)[2] > 1){
       stop(paste("Your summary file should only have 1 (tab-delimited) column of values.",
       sprintf("it has %s columns", dim(df)[2])))
   }
   print('read table output:')
   print(paste('Df dimensions', dim(df)))
   # Make an empty list to gather param values
   param_lst = setNames(vector("list", dim(df)[1]), rownames(df))
   # If a summary file entry is missing, raise an error
   for (idx in rownames(df)){
       if (df[idx,] == "") {
           stop(paste(sprintf('The parameter %s is missing!', idx),
                              'in your xcms_params file'))
       }
       # if no alphabetic characters, convert character to numeric
       digit = grepl("[[:digit:]]", df[idx,])
       alpha = grepl("[[:alpha:]]", df[idx,])
       if (digit &&! alpha) {
           sprintf('%s is a number(s)', df[idx,])
           param_lst[[idx]] = char_to_numeric(df[idx,])
       
       } else if (alpha){ # Anything that isn't all numbers is string
	   print('Setting this as parameter')
           print(df[idx,])
           param_lst[[idx]] = df[idx,]
       }
    }
    return(param_lst)
}

# Run xcms with parameters from a file generated by IPO
run_xcms = function(xcms_params, output_dir, data_dir)
{
  # INPUT - 
  #    xcms_params - a named-list containing xcms parameters
  #       It's origin is from a preset value or a summary file
  #       parsed through the function get_params() 
  # FUNCTION - Runs xcms with the supplied parameters
  #    doing a group-retcor-group pass
  # OUTPUT - A feature table, retcor deviation plot, and xcmsSet
  #    objects after each grouping stage of xcms
  #    output xcmsSet incase you want to repeat the group-retcor-group
  #    again (TODO: not implemented)
  
  # CALL - To call this function, use
  # run_xcms(xcms_params, output_dir)
  #     xcms_params will come from the get_params function 
  # The parameters will be adopted from the summary file
  # xcms_params
  
  # first, create the output directory if doesn't exist
  dir.create(output_dir)	
  
  # escape spaces in data_dir path
  xcms_feature_table = "xcms_result"
  camera_feature_table = "xcms_camera_results.csv"
  # nSlaves=0
  
  ### change working directory to your files
  ### TODO - this can probably be changed - xcms certainly has
  ### a way to point to files
  setwd(data_dir)
  print(getwd())
  
  #stop("Don't run xcms while you're debugging")
  
  # Load packages
  # library(xcms)
  # TODO - Learn to set the number of cores
  #register(MulticoreParam(4))
  
  # Detect peaks
  xset <- xcms::xcmsSet(
    method = "centWave",
    peakwidth = xcms_params$peak_width,
    ppm         = xcms_params$ppm,
    noise       = xcms_params$noise,
    snthresh    = xcms_params$snthresh,
    mzdiff      = xcms_params$mzdiff,
    prefilter   = xcms_params$prefilter,
    mzCenterFun = xcms_params$mzCenterFun,
    integrate   = xcms_params$integrate
  )
  
  print("finished peak Detection!")
  # Group peaks together across samples
  # save the detected peaks in case downstream processing fails 
  # and you have to go in manually to figure out parameters
  # TODO - should the bw parameter here be changed depending
  # on the platform used (i.e. bw=30 is default, but for uplc, 
  # maybe the coarse grouping should be bw=15 or something)
  xset <- xcms::group(
    xset, 
    method  = "density", 
    bw      = xcms_params$bw * 2, # First binning step should be generous 
    mzwid   = xcms_params$mzwid, 
    minfrac = xcms_params$minfrac, 
    minsamp = xcms_params$minsamp, 
    max     = xcms_params$max
  )
  print("finished first group command!")
  print(xset)
  saveRDS(xset, paste(output_dir, '/grouped.Rdata', sep=''))
  
  # Try to retention-correct
  xset2 <- xcms::retcor(xset, 
                        method         = xcms_params$retcor_method,
                        plottype       = 'deviation', 
                        distFunc       = xcms_params$distFunc,
                        profStep       = xcms_params$profStep, 
                        center         = xcms_params$center, 
                        response       = xcms_params$response, 
                        gapInit        = xcms_params$gapInit, 
                        gapExtend      = xcms_params$gapExtend,
                        factorDiag     = xcms_params$factorDiag,
                        factorGap      = xcms_params$factorGap, 
                        localAlignment = xcms_params$localAlignment)
  
  print("finished retcor!")
  
  # regroup after retention time correction
  xset2 <- xcms::group(
    xset2, 
    method  = "density", 
    bw      = xcms_params$bw, # Second binning step should be more strict 
    mzwid   = xcms_params$mzwid, 
    minfrac = xcms_params$minfrac, 
    minsamp = xcms_params$minsamp, 
    max     = xcms_params$max
  )
  saveRDS(xset2, paste(output_dir, '/grouped_retcor.Rdata', sep=''))
  print("finished second group command!")
  
  # Fill in peaks that weren't detected
  xset3 <- xcms::fillPeaks(xset2)
  print("Finished filling peaks!")
  print(xset3)
  # Move back to output_dir and write out your feature table
  setwd(output_dir)
  xcms_peaklist = xcms::peakTable(xset3, filebase=xcms_feature_table)
  message("Finished xcms!")
}

print(args$summaryfile)
print(is.null(args$summaryfile))
print(paste('class of summary file:', class(args$summaryfile)))

# if they don't give a sample summary file, raise an error
if (is.null(args$summaryfile) ) {
    stop(paste("You didn't pass any parameters.",
 "Please generate a params file using generate_xcms_params.R ",
 "You will need to edit the output of generate_xcms_params.R",
 "after it has run if you don't choose a preset"))
    }
if (is.null(args$output) | is.null(args$data)) {
	stop("You didn't provide an output directory (--output)
		   or a data directory (--data). Please do so.")
}

# if summary file, parse it and get the values
if (is.character(args$summaryfile)){
    xcms_params <- get_params(args$summaryfile, char_to_numeric)  
    print(xcms_params)
}


set_absolute_path <- function(local_path, given_path) {
  # Decide whether or not user gave you have an absolute path
  # if the known local path (non-git path) if present
  # then assume it's absolute
 

  # If local path is in the path given on command line, return 
  # command line path. Otherwise, add the local path to it
  if (grepl(local_path, given_path)){
    print('Absolute path given')
    return(given_path)
  } else {
    print('relative path given')
    return(paste(local_path, given_path, sep='/'))
  }

}

#TODO Add run_xcms function and how to extract parameters from lists
# and what to do with values not given
# check if value is in your user-defined parameters. if so, define it
# peak detection params
if (is.null(args$data)) {
    stop('You need to specify the directory where your data is (--data).
	That way xcms can find it')
}

# TODO - make os-agnostic (replace backslashes) 
# setwd so that paths are likely to be relative if they're
# operating in sub-directories, or absolute if operating outside
# current directory tree
setwd(getwd())
local_path = system('git rev-parse --show-toplevel', intern=TRUE)
output_path = args$output  # set_absolute_path(local_path, args$output)  
data_path = args$data  #set_absolute_path(local_path, args$data)
print('Output directory!')
print(output_path)
print('data path!')
print(data_path)
# Done - test for full summary file
# Done - fails for missing items - test for partial summary file
# Done - test for summary file

run_xcms(xcms_params, output_path, data_path)
